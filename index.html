<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Solid Chat</title>
  <meta name="description" content="Modern, decentralized chat app for Solid pods. Your messages, your control.">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://solid-chat.com/app">
  <meta property="og:title" content="Solid Chat App">
  <meta property="og:description" content="Modern, decentralized chat app for Solid pods. Your messages, your control.">
  <meta property="og:image" content="https://solid-chat.com/og-image.png">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://solid-chat.com/app">
  <meta name="twitter:title" content="Solid Chat App">
  <meta name="twitter:description" content="Modern, decentralized chat app for Solid pods. Your messages, your control.">
  <meta name="twitter:image" content="https://solid-chat.com/og-image.png">

  <!-- Additional Meta -->
  <meta name="theme-color" content="#667eea">
  <link rel="canonical" href="https://solid-chat.com/app">
  <link rel="icon" type="image/svg+xml" href="icons/icon.svg">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <link rel="manifest" href="manifest.json">

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- Theme CSS - loaded dynamically -->
  <link id="theme-css" rel="stylesheet" href="themes/wave.css">

  <style>
    /* Base styles that don't change between themes */
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
    }
  </style>
</head>
<body>

<div class="app-wrapper">
  <div class="app-banner">
    <div class="brand">
      <h1>Solid Chat</h1>
      <p>Decentralized messaging</p>
    </div>
  </div>

  <div class="sidebar-overlay" id="sidebarOverlay"></div>

  <div class="app-container">
    <!-- Left Panel - Chat List -->
    <aside class="left-panel" id="leftPanel">
      <div class="panel-header">
        <div class="header-left">
          <div class="user-avatar" id="userAvatar">S</div>
          <div>
            <div class="header-title">Solid Chat <span class="header-version" id="appVersion"></span></div>
          </div>
        </div>
        <div class="header-actions">
        </div>
      </div>

      <div class="sidebar" id="sidebar"></div>

      <div class="sidebar-footer">
        <select id="sidebarThemeSelect" class="sidebar-theme-select" title="Switch theme">
          <option value="solid">Solid</option>
          <option value="wave">Wave</option>
          <option value="telegram">Telegram</option>
          <option value="signal">Signal</option>
        </select>
      </div>
    </aside>

    <!-- Right Panel - Chat -->
    <main class="right-panel">
      <div class="content-header">
        <div class="header-left">
          <button class="mobile-menu-btn" id="mobileMenuBtn">‚ò∞</button>
          <span id="userStatus" class="user-status">Loading...</span>
        </div>
        <div class="header-right" id="headerLoginArea">
          <span id="loginArea"></span>
        </div>
      </div>

      <div class="chat-area">
        <div id="chatContainer">
          <div class="placeholder" id="placeholder">
            <div class="placeholder-icon">üí¨</div>
            <h2>Welcome to Solid Chat</h2>
            <p>Send and receive messages from your Solid POD.<br>Your data stays with you, always.<br><br>Select a chat from the sidebar or add a new one.</p>
          </div>
        </div>
      </div>
    </main>
  </div>
</div>

<div class="status-badge" id="statusBadge">
  <div class="status-dot"></div>
  <span>Connected</span>
</div>

<!-- Load rdflib and Solid auth -->
<script src="https://cdn.jsdelivr.net/npm/rdflib@2.2.33/dist/rdflib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@inrupt/solid-client-authn-browser@2.2.6/dist/solid-client-authn.bundle.js"></script>

<script type="module">
import { longChatPane } from './src/longChatPane.js'
import { chatListPane, addChat, updateChatPreview, incrementUnread, resetUnread } from './src/chatListPane.js'

// Theme management
const THEMES = {
  wave: { name: 'Wave', file: 'themes/wave.css' },
  solid: { name: 'Solid', file: 'themes/solid.css' },
  telegram: { name: 'Telegram', file: 'themes/telegram.css' },
  signal: { name: 'Signal', file: 'themes/signal.css' }
}

function loadTheme(themeName) {
  const theme = THEMES[themeName] || THEMES.wave
  const themeLink = document.getElementById('theme-css')
  themeLink.href = theme.file
  localStorage.setItem('solidchat-theme', themeName)

  // Update sidebar select
  const sidebarSelect = document.getElementById('sidebarThemeSelect')
  if (sidebarSelect) sidebarSelect.value = themeName

  // Update title based on theme
  const titles = { wave: 'Wave', solid: 'Solid Chat', telegram: 'Telegram', signal: 'Signal' }
  document.title = titles[themeName] || 'Solid Chat'
  document.querySelector('.header-title').innerHTML = `${titles[themeName]} <span class="header-version" id="appVersion"></span>`

  // Reload version
  fetch('./package.json')
    .then(r => r.json())
    .then(pkg => {
      const el = document.getElementById('appVersion')
      if (el) el.textContent = `v${pkg.version}`
    })
    .catch(() => {})
}

function initTheme() {
  const saved = localStorage.getItem('solidchat-theme') || 'solid'
  loadTheme(saved)

  document.getElementById('sidebarThemeSelect').addEventListener('change', (e) => {
    loadTheme(e.target.value)
  })
}

// Wait for libraries to be available
async function waitForLibraries() {
  return new Promise((resolve) => {
    const check = setInterval(() => {
      if (typeof $rdf !== 'undefined' && typeof solidClientAuthentication !== 'undefined') {
        clearInterval(check)
        resolve()
      }
    }, 50)
  })
}

await waitForLibraries()

// Get Solid auth functions
const { login, logout, handleIncomingRedirect, getDefaultSession } = solidClientAuthentication

// DOM elements
const chatContainer = document.getElementById('chatContainer')
const placeholder = document.getElementById('placeholder')
const userStatus = document.getElementById('userStatus')
const loginArea = document.getElementById('loginArea')
const sidebar = document.getElementById('sidebar')
const leftPanel = document.getElementById('leftPanel')
const mobileMenuBtn = document.getElementById('mobileMenuBtn')
const sidebarOverlay = document.getElementById('sidebarOverlay')
const statusBadge = document.getElementById('statusBadge')

// Mobile menu toggle
mobileMenuBtn.addEventListener('click', () => {
  leftPanel.classList.toggle('open')
  sidebarOverlay.classList.toggle('open')
})

sidebarOverlay.addEventListener('click', () => {
  leftPanel.classList.remove('open')
  sidebarOverlay.classList.remove('open')
})

// Auth state
let currentSession = null
let currentWebId = null

// Handle redirect callback from IdP
async function handleAuthRedirect() {
  userStatus.textContent = 'Checking login...'

  try {
    await handleIncomingRedirect({ restorePreviousSession: true })
    currentSession = getDefaultSession()

    if (currentSession.info.isLoggedIn) {
      currentWebId = currentSession.info.webId
      await updateAuthUI(true)
    } else {
      await updateAuthUI(false)
    }
  } catch (err) {
    console.error('Auth redirect error:', err)
    await updateAuthUI(false)
  }
}

// Update UI based on auth state
async function updateAuthUI(isLoggedIn) {
  if (isLoggedIn && currentWebId) {
    const shortId = currentWebId.split('//')[1]?.split('/')[0] || currentWebId
    userStatus.innerHTML = `Logged in as <a href="${currentWebId}" target="_blank">${shortId}</a>`
    loginArea.innerHTML = `<button class="btn btn-secondary" id="logoutBtn">Logout</button>`
    document.getElementById('logoutBtn').addEventListener('click', handleLogout)

    // Update avatar with user initial
    const initial = shortId.charAt(0).toUpperCase()
    document.getElementById('userAvatar').textContent = initial

    // Add Saved Messages to chat list (pinned at top)
    const savedMessagesUrl = await ensureSavedMessagesChat()
    if (savedMessagesUrl) {
      addChat(savedMessagesUrl, 'üìå Saved Messages', 'Private notes to yourself')
    }
  } else {
    userStatus.textContent = 'Not logged in'
    loginArea.innerHTML = `
      <input type="text" class="input-field" id="idpInput" placeholder="e.g. solidweb.org">
      <button class="btn btn-primary" id="loginBtn">Login</button>
    `
    document.getElementById('loginBtn').addEventListener('click', handleLogin)
    document.getElementById('idpInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') handleLogin()
    })
  }
}

// Handle login
async function handleLogin() {
  const idpInput = document.getElementById('idpInput')
  let idp = idpInput.value.trim() || 'solidweb.org'

  // Add https if missing
  if (!idp.startsWith('http')) {
    idp = 'https://' + idp
  }

  userStatus.textContent = 'Redirecting to login...'

  try {
    await login({
      oidcIssuer: idp,
      redirectUrl: window.location.href,
      clientName: 'Solid Chat'
    })
  } catch (err) {
    console.error('Login error:', err)
    userStatus.textContent = 'Login failed: ' + err.message
  }
}

// Handle logout
async function handleLogout() {
  try {
    await logout()
    currentSession = null
    currentWebId = null
    await updateAuthUI(false)
  } catch (err) {
    console.error('Logout error:', err)
  }
}

// Get authenticated fetch function
function getAuthFetch() {
  if (currentSession?.info?.isLoggedIn) {
    return currentSession.fetch
  }
  return fetch.bind(window)
}

// Get globals from rdflib with authenticated fetch
const store = $rdf.graph()
const fetcher = new $rdf.Fetcher(store, { fetch: getAuthFetch() })
store.fetcher = fetcher
store.rdflib = $rdf

// Update fetcher when auth changes
function updateFetcher() {
  store.fetcher = new $rdf.Fetcher(store, { fetch: getAuthFetch() })
}

// Simple updater with authenticated fetch
store.updater = {
  update: async function(del, ins) {
    const doc = ins[0]?.why || del[0]?.why
    if (!doc) throw new Error('No document to update')

    // Serialize insertions as N3
    let body = ''
    for (const st of ins) {
      body += `${st.subject.toNT()} ${st.predicate.toNT()} ${st.object.toNT()} .\n`
    }

    const authFetch = getAuthFetch()
    const response = await authFetch(doc.value, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/sparql-update'
      },
      body: `INSERT DATA { ${body} }`
    })

    if (!response.ok) {
      throw new Error(`Failed to update: ${response.status}`)
    }

    // Update local store
    for (const st of ins) {
      store.add(st.subject, st.predicate, st.object, st.why)
    }
  }
}

// Create context for pane
function createContext(uri) {
  // Use real logged in user, or mock for local test
  const isLocalChat = uri.includes('test/chat.ttl') || uri.startsWith('./')
  let user = null

  if (currentWebId) {
    user = $rdf.sym(currentWebId)
  } else if (isLocalChat) {
    user = $rdf.sym('https://melvin.solid.social/profile/card#me')
  }

  // Update fetcher with current auth
  updateFetcher()

  return {
    dom: document,
    session: {
      store: store,
      logic: {
        authn: {
          currentUser: () => user
        }
      }
    },
    authFetch: getAuthFetch
  }
}

// WebSocket for real-time updates
let currentWebSocket = null
let currentChatUri = null
let reconnectTimeout = null

// Notification sound
let soundEnabled = localStorage.getItem('solidchat-sound') !== 'false'

function playNotificationSound() {
  if (!soundEnabled) return

  const ctx = new AudioContext()

  // First tone (D5)
  const osc1 = ctx.createOscillator()
  const gain1 = ctx.createGain()
  osc1.connect(gain1)
  gain1.connect(ctx.destination)
  osc1.frequency.value = 587.33
  gain1.gain.setValueAtTime(0.2, ctx.currentTime)
  gain1.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2)
  osc1.start()
  osc1.stop(ctx.currentTime + 0.2)

  // Second tone (A5)
  const osc2 = ctx.createOscillator()
  const gain2 = ctx.createGain()
  osc2.connect(gain2)
  gain2.connect(ctx.destination)
  osc2.frequency.value = 880
  gain2.gain.setValueAtTime(0.2, ctx.currentTime + 0.15)
  gain2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4)
  osc2.start(ctx.currentTime + 0.15)
  osc2.stop(ctx.currentTime + 0.4)
}

function toggleSound() {
  soundEnabled = !soundEnabled
  localStorage.setItem('solidchat-sound', soundEnabled)
  updateSoundButton()
}

function updateSoundButton() {
  const btn = document.getElementById('soundToggle')
  if (btn) {
    btn.innerHTML = soundEnabled
      ? '<svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"/></svg>'
      : '<svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.64 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z"/><line x1="3" y1="3" x2="21" y2="21" stroke="currentColor" stroke-width="2"/></svg>'
  }
}

// Subscribe to real-time updates for a resource
async function subscribeToUpdates(uri) {
  // Close existing connection
  if (currentWebSocket) {
    currentWebSocket.close()
    currentWebSocket = null
  }
  if (reconnectTimeout) {
    clearTimeout(reconnectTimeout)
    reconnectTimeout = null
  }

  const authFetch = getAuthFetch()
  currentChatUri = uri

  try {
    const url = new URL(uri)

    // Check if solidcommunity.net - use WebSocketChannel2023
    if (url.host.endsWith('solidcommunity.net')) {
      await subscribeWebSocketChannel2023(uri, authFetch)
      return
    }

    // Otherwise try legacy Updates-Via
    const response = await authFetch(uri, { method: 'HEAD' })
    const updatesVia = response.headers.get('Updates-Via')

    if (!updatesVia) {
      console.log('No Updates-Via header, real-time updates not available')
      return
    }

    console.log('Subscribing to updates via:', updatesVia)
    connectLegacyWebSocket(updatesVia, uri)

  } catch (err) {
    console.error('Failed to subscribe to updates:', err)
  }
}

// WebSocketChannel2023 (CSS/solidcommunity.net)
async function subscribeWebSocketChannel2023(uri, authFetch) {
  try {
    const response = await authFetch('https://solidcommunity.net/.notifications/WebSocketChannel2023/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/ld+json' },
      body: JSON.stringify({
        "@context": ["https://www.w3.org/ns/solid/notification/v1"],
        "type": "http://www.w3.org/ns/solid/notifications#WebSocketChannel2023",
        "topic": uri
      })
    })

    if (!response.ok) {
      console.log('WebSocketChannel2023 subscription failed:', response.status)
      return
    }

    const { receiveFrom } = await response.json()
    console.log('WebSocketChannel2023 connecting to:', receiveFrom)

    currentWebSocket = new WebSocket(receiveFrom)

    currentWebSocket.onopen = () => {
      console.log('WebSocketChannel2023 connected')
    }

    currentWebSocket.onmessage = (event) => {
      console.log('WebSocketChannel2023 notification:', event.data)
      // Any message means the resource changed
      playNotificationSound()
      if (document.hidden) {
        incrementUnread(uri)
      }
      setTimeout(() => refreshChat(), 1500)
    }

    currentWebSocket.onclose = () => {
      console.log('WebSocketChannel2023 closed')
      if (currentChatUri === uri) {
        reconnectTimeout = setTimeout(() => subscribeToUpdates(uri), 5000)
      }
    }

    currentWebSocket.onerror = (err) => {
      console.error('WebSocketChannel2023 error:', err)
    }

  } catch (err) {
    console.error('WebSocketChannel2023 failed:', err)
  }
}

// Legacy Updates-Via WebSocket (NSS)
function connectLegacyWebSocket(updatesVia, uri) {
  currentWebSocket = new WebSocket(updatesVia, ['solid-0.1'])

  currentWebSocket.onopen = () => {
    console.log('Legacy WebSocket connected')
    currentWebSocket.send(`sub ${uri}`)
  }

  currentWebSocket.onmessage = (event) => {
    const data = event.data
    console.log('Legacy WebSocket message:', data)

    if (data.startsWith('pub ')) {
      const updatedUri = data.slice(4).trim()
      if (updatedUri === uri || uri.startsWith(updatedUri)) {
        console.log('Chat updated, refreshing...')
        playNotificationSound()
        if (document.hidden) {
          incrementUnread(uri)
        }
        setTimeout(() => refreshChat(), 1500)
      }
    }
  }

  currentWebSocket.onclose = () => {
    console.log('Legacy WebSocket closed')
    if (currentChatUri === uri) {
      reconnectTimeout = setTimeout(() => subscribeToUpdates(uri), 5000)
    }
  }

  currentWebSocket.onerror = (err) => {
    console.error('Legacy WebSocket error:', err)
  }
}

// Debounce helper
function debounce(fn, delay) {
  let timeout
  return function(...args) {
    clearTimeout(timeout)
    timeout = setTimeout(() => fn.apply(this, args), delay)
  }
}

// Current pane element (for incremental refresh)
let currentPane = null

// Refresh current chat without full reload
async function doRefreshChat() {
  if (!currentChatUri) return

  // Use incremental refresh if pane supports it
  if (currentPane && currentPane.refresh) {
    try {
      await currentPane.refresh()
    } catch (err) {
      console.error('Error refreshing chat:', err)
    }
    return
  }

  // Fallback to full re-render
  const uri = currentChatUri
  try {
    const doc = $rdf.sym(uri).doc()
    store.removeMatches(null, null, null, doc)

    const subject = $rdf.sym(uri)
    const context = createContext(uri)

    chatContainer.innerHTML = ''
    currentPane = longChatPane.render(subject, context)
    chatContainer.appendChild(currentPane)

  } catch (err) {
    console.error('Error refreshing chat:', err)
  }
}

// Debounced version - prevents rapid re-renders
const refreshChat = debounce(doRefreshChat, 300)

// Load chat function
async function loadChat(uri) {
  if (!uri) {
    alert('Please enter a chat URI')
    return
  }

  // Convert relative URIs to absolute
  if (uri.startsWith('./') || uri.startsWith('../') || !uri.includes('://')) {
    uri = new URL(uri, window.location.href).href
  }

  // Close mobile sidebar if open
  leftPanel.classList.remove('open')
  sidebarOverlay.classList.remove('open')

  chatContainer.innerHTML = `
    <div class="placeholder">
      <div class="loading-spinner"></div>
      <p>Loading chat...</p>
    </div>
  `

  try {
    const subject = $rdf.sym(uri)
    const context = createContext(uri)

    // Clear container and render pane
    chatContainer.innerHTML = ''
    currentPane = null

    // Check if pane applies
    const label = longChatPane.label(subject, context)
    if (!label) {
      // Force render anyway for demo
      console.log('Pane label returned null, but rendering anyway for demo')
    }

    currentPane = longChatPane.render(subject, context)
    chatContainer.appendChild(currentPane)

    // Add to chat list (will also set as active)
    addChat(uri)
    chatListPane.setActiveChat(uri)

    // Subscribe to real-time updates
    currentChatUri = uri
    subscribeToUpdates(uri)

    // Remember current chat for page refresh
    localStorage.setItem('solidchat-current-room', uri)

  } catch (err) {
    console.error('Error loading chat:', err)
    chatContainer.innerHTML = `
      <div class="placeholder">
        <div class="placeholder-icon">‚ùå</div>
        <h2>Error Loading Chat</h2>
        <p>${err.message}</p>
      </div>
    `
  }
}

// Default global chat
const DEFAULT_CHAT_URI = 'https://solid-chat.solidweb.org/public/global/chat.ttl'

// Get user's pod root from WebID
async function getMyPodRoot() {
  if (!currentWebId) return null

  try {
    const profileDoc = $rdf.sym(currentWebId).doc()
    await store.fetcher.load(profileDoc)

    const PIM = $rdf.Namespace('http://www.w3.org/ns/pim/space#')
    const storage = store.any($rdf.sym(currentWebId), PIM('storage'))

    if (storage) {
      return storage.value
    }

    // Fallback: derive from WebID (e.g., https://user.pod/profile/card#me -> https://user.pod/)
    const url = new URL(currentWebId)
    return `${url.protocol}//${url.host}/`
  } catch (e) {
    console.warn('Failed to get pod root:', e)
    // Fallback
    const url = new URL(currentWebId)
    return `${url.protocol}//${url.host}/`
  }
}

// Create a new chat room
async function createChat(chatUrl, title) {
  // Default title from filename
  if (!title) {
    const filename = chatUrl.split('/').pop().replace('.ttl', '')
    title = filename
      .replace(/[-_]/g, ' ')
      .replace(/\b\w/g, c => c.toUpperCase())
  }

  const now = new Date().toISOString()
  const turtle = `@prefix dct: <http://purl.org/dc/terms/>.
@prefix meeting: <http://www.w3.org/ns/pim/meeting#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.

<>
    a meeting:LongChat ;
    dct:title "${title}" ;
    dct:created "${now}"^^xsd:dateTime .
`

  const authFetch = getAuthFetch()
  const response = await authFetch(chatUrl, {
    method: 'PUT',
    headers: { 'Content-Type': 'text/turtle' },
    body: turtle
  })

  if (!response.ok) {
    throw new Error(`Failed to create chat: ${response.status}`)
  }

  // Set public ACL and register in Type Index
  const isPublic = chatUrl.includes('/public/')
  if (isPublic) {
    await setPublicReadACL(chatUrl)
  }

  // Register in Type Index (don't await - do it in background)
  registerInTypeIndex(chatUrl, isPublic).catch(e => {
    console.warn('Type Index registration failed:', e)
  })

  return { url: chatUrl, title }
}

// Set public read ACL for a resource
async function setPublicReadACL(resourceUrl) {
  const aclUrl = resourceUrl + '.acl'
  const authFetch = getAuthFetch()

  const acl = `@prefix acl: <http://www.w3.org/ns/auth/acl#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.

<#public>
    a acl:Authorization ;
    acl:agentClass foaf:Agent ;
    acl:accessTo <${resourceUrl}> ;
    acl:mode acl:Read, acl:Append .

<#owner>
    a acl:Authorization ;
    acl:agent <${currentWebId}> ;
    acl:accessTo <${resourceUrl}> ;
    acl:mode acl:Read, acl:Write, acl:Control .
`

  try {
    await authFetch(aclUrl, {
      method: 'PUT',
      headers: { 'Content-Type': 'text/turtle' },
      body: acl
    })
  } catch (e) {
    console.warn('Failed to set ACL (might already exist):', e)
  }
}

// Set private ACL (owner-only) for Saved Messages
async function setPrivateACL(resourceUrl) {
  const aclUrl = resourceUrl + '.acl'
  const authFetch = getAuthFetch()

  const acl = `@prefix acl: <http://www.w3.org/ns/auth/acl#>.

<#owner>
    a acl:Authorization ;
    acl:agent <${currentWebId}> ;
    acl:accessTo <${resourceUrl}> ;
    acl:mode acl:Read, acl:Write, acl:Control .
`

  try {
    await authFetch(aclUrl, {
      method: 'PUT',
      headers: { 'Content-Type': 'text/turtle' },
      body: acl
    })
  } catch (e) {
    console.warn('Failed to set private ACL:', e)
  }
}

// Get URI for Saved Messages chat
function getSavedMessagesUri(podRoot) {
  return podRoot + 'private/saved-messages/chat.ttl'
}

// Ensure Saved Messages chat exists, create if not
async function ensureSavedMessagesChat() {
  if (!currentWebId) return null

  const podRoot = await getMyPodRoot()
  if (!podRoot) return null

  const chatUrl = getSavedMessagesUri(podRoot)
  const authFetch = getAuthFetch()

  // Check if chat already exists
  try {
    const response = await authFetch(chatUrl, { method: 'HEAD' })
    if (response.ok) {
      return chatUrl // Already exists
    }
  } catch (e) {
    // Doesn't exist, create it
  }

  // Create the chat
  const now = new Date().toISOString()
  const turtle = `@prefix dct: <http://purl.org/dc/terms/>.
@prefix meeting: <http://www.w3.org/ns/pim/meeting#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.

<>
    a meeting:LongChat ;
    dct:title "Saved Messages" ;
    dct:created "${now}"^^xsd:dateTime .
`

  try {
    const response = await authFetch(chatUrl, {
      method: 'PUT',
      headers: { 'Content-Type': 'text/turtle' },
      body: turtle
    })

    if (response.ok) {
      // Set private ACL
      await setPrivateACL(chatUrl)
      console.log('Created Saved Messages chat:', chatUrl)
      return chatUrl
    }
  } catch (e) {
    console.warn('Failed to create Saved Messages chat:', e)
  }

  return null
}

// Register chat in user's Type Index
async function registerInTypeIndex(chatUrl, isPublic = true) {
  if (!currentWebId) return

  try {
    // Load profile to find Type Index
    const profileDoc = $rdf.sym(currentWebId).doc()
    await store.fetcher.load(profileDoc)

    const SOLID = $rdf.Namespace('http://www.w3.org/ns/solid/terms#')
    const typeIndexPred = isPublic ? SOLID('publicTypeIndex') : SOLID('privateTypeIndex')
    const typeIndex = store.any($rdf.sym(currentWebId), typeIndexPred)

    if (!typeIndex) {
      console.warn('No Type Index found for user')
      return
    }

    // Check if already registered
    await store.fetcher.load(typeIndex)
    const MEETING = $rdf.Namespace('http://www.w3.org/ns/pim/meeting#')
    const existing = store.statementsMatching(null, SOLID('instance'), $rdf.sym(chatUrl), typeIndex.doc())
    if (existing.length > 0) {
      console.log('Chat already registered in Type Index')
      return
    }

    // Add registration
    const regId = `#chat-${Date.now()}`
    const insertQuery = `
      INSERT DATA {
        <${regId}> a <http://www.w3.org/ns/solid/terms#TypeRegistration> ;
          <http://www.w3.org/ns/solid/terms#forClass> <http://www.w3.org/ns/pim/meeting#LongChat> ;
          <http://www.w3.org/ns/solid/terms#instance> <${chatUrl}> .
      }
    `

    const authFetch = getAuthFetch()
    const response = await authFetch(typeIndex.value, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/sparql-update' },
      body: insertQuery
    })

    if (response.ok) {
      console.log('Chat registered in Type Index:', chatUrl)
    } else {
      console.warn('Failed to register in Type Index:', response.status)
    }
  } catch (e) {
    console.warn('Failed to register in Type Index:', e)
  }
}

// Handle deep link from URL params
async function handleDeepLink() {
  const params = new URLSearchParams(window.location.search)
  const chatUrl = params.get('chat')
  const title = params.get('title')

  if (!chatUrl) return null

  // Validate URL
  try {
    new URL(chatUrl)
  } catch {
    console.error('Invalid chat URL:', chatUrl)
    return null
  }

  const authFetch = getAuthFetch()

  try {
    // Check if chat exists
    const res = await authFetch(chatUrl, { method: 'HEAD' })

    if (res.ok) {
      // Exists - just return URL to load
      // Clean URL
      history.replaceState({}, '', window.location.pathname)
      return chatUrl
    } else if (res.status === 404) {
      // Doesn't exist - try to create if it's on our pod
      const myPod = await getMyPodRoot()
      if (myPod && chatUrl.startsWith(myPod)) {
        await createChat(chatUrl, title)
        // Clean URL
        history.replaceState({}, '', window.location.pathname)
        return chatUrl
      } else {
        alert('Chat not found. You can only create chats on your own pod.')
        history.replaceState({}, '', window.location.pathname)
        return null
      }
    } else if (res.status === 401 || res.status === 403) {
      // Need to login or no access
      alert('Login required or no access to this chat.')
      history.replaceState({}, '', window.location.pathname)
      return null
    }
  } catch (e) {
    console.error('Error handling deep link:', e)
  }

  return null
}

// Copy share link to clipboard
function copyShareLink(uri) {
  const shareUrl = `${window.location.origin}${window.location.pathname}?chat=${encodeURIComponent(uri)}`
  navigator.clipboard.writeText(shareUrl).then(() => {
    // Show toast
    showToast('Link copied to clipboard!')
  }).catch(err => {
    console.error('Failed to copy:', err)
    // Fallback: show URL in alert
    prompt('Copy this link:', shareUrl)
  })
}

// Toast notification
function showToast(message) {
  const existing = document.querySelector('.toast')
  if (existing) existing.remove()

  const toast = document.createElement('div')
  toast.className = 'toast'
  toast.textContent = message
  document.body.appendChild(toast)

  setTimeout(() => {
    toast.style.opacity = '0'
    toast.style.transition = 'opacity 0.3s'
    setTimeout(() => toast.remove(), 300)
  }, 2500)
}

// Make createChat and copyShareLink available globally for chatListPane
window.solidChat = { createChat, copyShareLink, getMyPodRoot }
window.toggleSound = toggleSound

// Detect bottom nav bar overlay and set CSS variable
function updateBottomOffset() {
  if (window.visualViewport) {
    const offset = window.innerHeight - window.visualViewport.height;
    document.documentElement.style.setProperty('--bottom-offset', `${Math.max(0, offset)}px`);
  }
}

// Initialize: handle auth redirect first, then render sidebar
async function init() {
  // Initialize theme
  initTheme()

  // Set up viewport detection for Android nav bar
  updateBottomOffset()
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', updateBottomOffset)
  }
  window.addEventListener('resize', updateBottomOffset)

  // Sound button is now created in chatListPane with onclick handler

  // Clear unread count when user returns to tab
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && currentChatUri) {
      resetUnread(currentChatUri)
      chatListPane.setActiveChat(currentChatUri)
    }
  })

  // Handle auth redirect callback (if returning from IdP)
  await handleAuthRedirect()

  // Create context for sidebar
  const sidebarContext = {
    dom: document,
    session: {
      store: store,
      webId: currentWebId
    }
  }

  // Render chat list sidebar
  const sidebarElement = chatListPane.render(sidebarContext, {
    onSelectChat: loadChat,
    webId: currentWebId
  })
  sidebar.appendChild(sidebarElement)

  // Move theme selector above Discover Chats button
  const discoverBtn = sidebar.querySelector('.discover-btn')
  const themeSelect = document.getElementById('sidebarThemeSelect')
  if (discoverBtn && themeSelect) {
    discoverBtn.parentNode.insertBefore(themeSelect.parentNode, discoverBtn)
  }

  // Check for ?chat= deep link first, then ?uri= (legacy), then saved room, then default
  const deepLinkedChat = await handleDeepLink()
  if (deepLinkedChat) {
    loadChat(deepLinkedChat)
  } else {
    const params = new URLSearchParams(window.location.search)
    const savedRoom = localStorage.getItem('solidchat-current-room')
    const initialUri = params.get('uri') || savedRoom || DEFAULT_CHAT_URI
    loadChat(initialUri)
  }
}

init()
</script>

</body>
</html>
