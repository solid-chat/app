<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Solid Chat</title>
  <meta name="description" content="Modern, decentralized chat app for Solid pods. Your messages, your control.">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://solid-chat.com/app">
  <meta property="og:title" content="Solid Chat App">
  <meta property="og:description" content="Modern, decentralized chat app for Solid pods. Your messages, your control.">
  <meta property="og:image" content="https://solid-chat.com/og-image.png">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://solid-chat.com/app">
  <meta name="twitter:title" content="Solid Chat App">
  <meta name="twitter:description" content="Modern, decentralized chat app for Solid pods. Your messages, your control.">
  <meta name="twitter:image" content="https://solid-chat.com/og-image.png">

  <!-- Additional Meta -->
  <meta name="theme-color" content="#667eea">
  <link rel="canonical" href="https://solid-chat.com/app">
  <link rel="icon" type="image/svg+xml" href="icons/icon.svg">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <link rel="manifest" href="manifest.json">

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --gradient-start: #667eea;
      --gradient-end: #9f7aea;
      --bg: #f7f8fc;
      --text: #2d3748;
      --text-muted: #a0aec0;
      --accent: #805ad5;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    .app-header {
      background: linear-gradient(135deg, var(--gradient-start), var(--gradient-end));
      color: white;
      padding: 16px 24px;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .app-header h1 {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .app-header p {
      font-size: 0.8rem;
      opacity: 0.9;
    }

    .app-header button {
      padding: 6px 14px;
      background: rgba(255,255,255,0.2);
      color: white;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    .app-header button:hover {
      background: rgba(255,255,255,0.3);
    }

    .app-header input {
      padding: 6px 10px;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 6px;
      font-size: 12px;
      background: rgba(255,255,255,0.15);
      color: white;
      width: 140px;
    }

    .app-header input::placeholder {
      color: rgba(255,255,255,0.7);
    }

    #chatContainer {
      background: white;
      overflow: hidden;
      height: 100%;
    }

    .placeholder {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--text-muted);
      text-align: center;
    }

    .placeholder-icon {
      font-size: 64px;
      margin-bottom: 16px;
    }

    .placeholder h2 {
      color: var(--text);
      margin-bottom: 8px;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #e0e0e0;
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 16px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .error {
      background: #fff3f3;
      border: 1px solid #ffcdd2;
      color: #c62828;
      padding: 16px;
      border-radius: 8px;
      margin-top: 16px;
    }

    /* App layout with sidebar */
    .app-layout {
      display: flex;
      height: calc(100vh - 68px);
    }

    .sidebar {
      width: 320px;
      flex-shrink: 0;
      height: 100%;
      overflow: hidden;
    }

    .main-content {
      flex: 1;
      overflow: hidden;
      background: var(--bg);
      height: 100%;
    }

    /* Mobile hamburger */
    .mobile-menu-btn {
      display: none;
      width: 40px;
      height: 40px;
      background: rgba(255,255,255,0.2);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 24px;
      cursor: pointer;
      align-items: center;
      justify-content: center;
    }

    .sidebar-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 99;
    }

    @media (max-width: 768px) {
      .mobile-menu-btn {
        display: flex;
      }

      .sidebar {
        position: fixed;
        top: 0;
        left: -320px;
        height: 100vh;
        z-index: 100;
        transition: left 0.3s ease;
        box-shadow: 4px 0 20px rgba(0,0,0,0.2);
      }

      .sidebar.open {
        left: 0;
      }

      .sidebar-overlay.open {
        display: block;
      }

      .app-layout {
        height: calc(100vh - 68px);
      }

      .main-content {
        width: 100%;
      }
    }
  </style>
</head>
<body>

<header class="app-header">
  <button class="mobile-menu-btn" id="mobileMenuBtn">‚ò∞</button>
  <div>
    <h1>Solid Chat</h1>
    <p>Decentralized messaging for the web</p>
  </div>
  <div id="headerLoginArea" style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
    <button id="soundToggle" title="Toggle notification sound" style="background: none; border: none; font-size: 18px; cursor: pointer; padding: 4px;">üîî</button>
    <span id="userStatus" style="font-size: 13px; opacity: 0.9;">Loading...</span>
    <span id="loginArea"></span>
  </div>
</header>

<div class="sidebar-overlay" id="sidebarOverlay"></div>

<div class="app-layout">
  <aside class="sidebar" id="sidebar"></aside>

  <main class="main-content">
    <div id="chatContainer">
      <div class="placeholder" id="placeholder">
        <div class="placeholder-icon">üí¨</div>
        <h2>Welcome to Solid Chat</h2>
        <p>Select a chat from the sidebar<br>or add a new one with the + button.</p>
      </div>
    </div>
  </main>
</div>

<!-- Load rdflib and Solid auth -->
<script src="https://cdn.jsdelivr.net/npm/rdflib@2.2.33/dist/rdflib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@inrupt/solid-client-authn-browser@2.2.6/dist/solid-client-authn.bundle.js"></script>

<script type="module">
import { longChatPane } from './src/longChatPane.js'
import { chatListPane, addChat, updateChatPreview } from './src/chatListPane.js'

// Wait for libraries to be available
async function waitForLibraries() {
  return new Promise((resolve) => {
    const check = setInterval(() => {
      if (typeof $rdf !== 'undefined' && typeof solidClientAuthentication !== 'undefined') {
        clearInterval(check)
        resolve()
      }
    }, 50)
  })
}

await waitForLibraries()

// Get Solid auth functions
const { login, logout, handleIncomingRedirect, getDefaultSession } = solidClientAuthentication

// DOM elements
const chatContainer = document.getElementById('chatContainer')
const placeholder = document.getElementById('placeholder')
const userStatus = document.getElementById('userStatus')
const loginArea = document.getElementById('loginArea')
const sidebar = document.getElementById('sidebar')
const mobileMenuBtn = document.getElementById('mobileMenuBtn')
const sidebarOverlay = document.getElementById('sidebarOverlay')

// Mobile menu toggle
mobileMenuBtn.addEventListener('click', () => {
  sidebar.classList.toggle('open')
  sidebarOverlay.classList.toggle('open')
})

sidebarOverlay.addEventListener('click', () => {
  sidebar.classList.remove('open')
  sidebarOverlay.classList.remove('open')
})

// Auth state
let currentSession = null
let currentWebId = null

// Handle redirect callback from IdP
async function handleAuthRedirect() {
  userStatus.textContent = 'Checking login...'

  try {
    await handleIncomingRedirect({ restorePreviousSession: true })
    currentSession = getDefaultSession()

    if (currentSession.info.isLoggedIn) {
      currentWebId = currentSession.info.webId
      updateAuthUI(true)
    } else {
      updateAuthUI(false)
    }
  } catch (err) {
    console.error('Auth redirect error:', err)
    updateAuthUI(false)
  }
}

// Update UI based on auth state
function updateAuthUI(isLoggedIn) {
  if (isLoggedIn && currentWebId) {
    const shortId = currentWebId.split('//')[1]?.split('/')[0] || currentWebId
    userStatus.innerHTML = `Logged in as <strong><a href="${currentWebId}" target="_blank" style="color: white; text-decoration: underline; text-underline-offset: 2px;">${shortId}</a></strong>`
    loginArea.innerHTML = `<button id="logoutBtn">Logout</button>`
    document.getElementById('logoutBtn').addEventListener('click', handleLogout)
  } else {
    userStatus.textContent = 'Not logged in'
    loginArea.innerHTML = `
      <input type="text" id="idpInput" placeholder="solidcommunity.net" style="padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 13px; width: 160px;">
      <button id="loginBtn">Login</button>
    `
    document.getElementById('loginBtn').addEventListener('click', handleLogin)
    document.getElementById('idpInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') handleLogin()
    })
  }
}

// Handle login
async function handleLogin() {
  const idpInput = document.getElementById('idpInput')
  let idp = idpInput.value.trim() || 'solidcommunity.net'

  // Add https if missing
  if (!idp.startsWith('http')) {
    idp = 'https://' + idp
  }

  userStatus.textContent = 'Redirecting to login...'

  try {
    await login({
      oidcIssuer: idp,
      redirectUrl: window.location.href,
      clientName: 'Solid Chat'
    })
  } catch (err) {
    console.error('Login error:', err)
    userStatus.textContent = 'Login failed: ' + err.message
  }
}

// Handle logout
async function handleLogout() {
  try {
    await logout()
    currentSession = null
    currentWebId = null
    updateAuthUI(false)
  } catch (err) {
    console.error('Logout error:', err)
  }
}

// Get authenticated fetch function
function getAuthFetch() {
  if (currentSession?.info?.isLoggedIn) {
    return currentSession.fetch
  }
  return fetch.bind(window)
}

// Get globals from rdflib with authenticated fetch
const store = $rdf.graph()
const fetcher = new $rdf.Fetcher(store, { fetch: getAuthFetch() })
store.fetcher = fetcher
store.rdflib = $rdf

// Update fetcher when auth changes
function updateFetcher() {
  store.fetcher = new $rdf.Fetcher(store, { fetch: getAuthFetch() })
}

// Simple updater with authenticated fetch
store.updater = {
  update: async function(del, ins) {
    const doc = ins[0]?.why || del[0]?.why
    if (!doc) throw new Error('No document to update')

    // Serialize insertions as N3
    let body = ''
    for (const st of ins) {
      body += `${st.subject.toNT()} ${st.predicate.toNT()} ${st.object.toNT()} .\n`
    }

    const authFetch = getAuthFetch()
    const response = await authFetch(doc.value, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/sparql-update'
      },
      body: `INSERT DATA { ${body} }`
    })

    if (!response.ok) {
      throw new Error(`Failed to update: ${response.status}`)
    }

    // Update local store
    for (const st of ins) {
      store.add(st.subject, st.predicate, st.object, st.why)
    }
  }
}

// Create context for pane
function createContext(uri) {
  // Use real logged in user, or mock for local test
  const isLocalChat = uri.includes('test/chat.ttl') || uri.startsWith('./')
  let user = null

  if (currentWebId) {
    user = $rdf.sym(currentWebId)
  } else if (isLocalChat) {
    user = $rdf.sym('https://melvin.solid.social/profile/card#me')
  }

  // Update fetcher with current auth
  updateFetcher()

  return {
    dom: document,
    session: {
      store: store,
      logic: {
        authn: {
          currentUser: () => user
        }
      }
    },
    authFetch: getAuthFetch
  }
}

// WebSocket for real-time updates
let currentWebSocket = null
let currentChatUri = null
let reconnectTimeout = null

// Notification sound
let soundEnabled = localStorage.getItem('solidchat-sound') !== 'false'

function playNotificationSound() {
  if (!soundEnabled || !document.hidden) return

  const ctx = new AudioContext()

  // First tone (D5)
  const osc1 = ctx.createOscillator()
  const gain1 = ctx.createGain()
  osc1.connect(gain1)
  gain1.connect(ctx.destination)
  osc1.frequency.value = 587.33
  gain1.gain.setValueAtTime(0.2, ctx.currentTime)
  gain1.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2)
  osc1.start()
  osc1.stop(ctx.currentTime + 0.2)

  // Second tone (A5)
  const osc2 = ctx.createOscillator()
  const gain2 = ctx.createGain()
  osc2.connect(gain2)
  gain2.connect(ctx.destination)
  osc2.frequency.value = 880
  gain2.gain.setValueAtTime(0.2, ctx.currentTime + 0.15)
  gain2.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4)
  osc2.start(ctx.currentTime + 0.15)
  osc2.stop(ctx.currentTime + 0.4)
}

function toggleSound() {
  soundEnabled = !soundEnabled
  localStorage.setItem('solidchat-sound', soundEnabled)
  updateSoundButton()
}

function updateSoundButton() {
  const btn = document.getElementById('soundToggle')
  if (btn) btn.textContent = soundEnabled ? 'üîî' : 'üîï'
}

// Subscribe to real-time updates for a resource
async function subscribeToUpdates(uri) {
  // Close existing connection
  if (currentWebSocket) {
    currentWebSocket.close()
    currentWebSocket = null
  }
  if (reconnectTimeout) {
    clearTimeout(reconnectTimeout)
    reconnectTimeout = null
  }

  const authFetch = getAuthFetch()
  currentChatUri = uri

  try {
    const url = new URL(uri)

    // Check if solidcommunity.net - use WebSocketChannel2023
    if (url.host.endsWith('solidcommunity.net')) {
      await subscribeWebSocketChannel2023(uri, authFetch)
      return
    }

    // Otherwise try legacy Updates-Via
    const response = await authFetch(uri, { method: 'HEAD' })
    const updatesVia = response.headers.get('Updates-Via')

    if (!updatesVia) {
      console.log('No Updates-Via header, real-time updates not available')
      return
    }

    console.log('Subscribing to updates via:', updatesVia)
    connectLegacyWebSocket(updatesVia, uri)

  } catch (err) {
    console.error('Failed to subscribe to updates:', err)
  }
}

// WebSocketChannel2023 (CSS/solidcommunity.net)
async function subscribeWebSocketChannel2023(uri, authFetch) {
  try {
    const response = await authFetch('https://solidcommunity.net/.notifications/WebSocketChannel2023/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/ld+json' },
      body: JSON.stringify({
        "@context": ["https://www.w3.org/ns/solid/notification/v1"],
        "type": "http://www.w3.org/ns/solid/notifications#WebSocketChannel2023",
        "topic": uri
      })
    })

    if (!response.ok) {
      console.log('WebSocketChannel2023 subscription failed:', response.status)
      return
    }

    const { receiveFrom } = await response.json()
    console.log('WebSocketChannel2023 connecting to:', receiveFrom)

    currentWebSocket = new WebSocket(receiveFrom)

    currentWebSocket.onopen = () => {
      console.log('WebSocketChannel2023 connected')
    }

    currentWebSocket.onmessage = (event) => {
      console.log('WebSocketChannel2023 notification:', event.data)
      // Any message means the resource changed
      playNotificationSound()
      setTimeout(() => refreshChat(), 500)
    }

    currentWebSocket.onclose = () => {
      console.log('WebSocketChannel2023 closed')
      if (currentChatUri === uri) {
        reconnectTimeout = setTimeout(() => subscribeToUpdates(uri), 5000)
      }
    }

    currentWebSocket.onerror = (err) => {
      console.error('WebSocketChannel2023 error:', err)
    }

  } catch (err) {
    console.error('WebSocketChannel2023 failed:', err)
  }
}

// Legacy Updates-Via WebSocket (NSS)
function connectLegacyWebSocket(updatesVia, uri) {
  currentWebSocket = new WebSocket(updatesVia, ['solid-0.1'])

  currentWebSocket.onopen = () => {
    console.log('Legacy WebSocket connected')
    currentWebSocket.send(`sub ${uri}`)
  }

  currentWebSocket.onmessage = (event) => {
    const data = event.data
    console.log('Legacy WebSocket message:', data)

    if (data.startsWith('pub ')) {
      const updatedUri = data.slice(4).trim()
      if (updatedUri === uri || uri.startsWith(updatedUri)) {
        console.log('Chat updated, refreshing...')
        playNotificationSound()
        setTimeout(() => refreshChat(), 500)
      }
    }
  }

  currentWebSocket.onclose = () => {
    console.log('Legacy WebSocket closed')
    if (currentChatUri === uri) {
      reconnectTimeout = setTimeout(() => subscribeToUpdates(uri), 5000)
    }
  }

  currentWebSocket.onerror = (err) => {
    console.error('Legacy WebSocket error:', err)
  }
}

// Debounce helper
function debounce(fn, delay) {
  let timeout
  return function(...args) {
    clearTimeout(timeout)
    timeout = setTimeout(() => fn.apply(this, args), delay)
  }
}

// Current pane element (for incremental refresh)
let currentPane = null

// Refresh current chat without full reload
async function doRefreshChat() {
  if (!currentChatUri) return

  // Use incremental refresh if pane supports it
  if (currentPane && currentPane.refresh) {
    try {
      await currentPane.refresh()
    } catch (err) {
      console.error('Error refreshing chat:', err)
    }
    return
  }

  // Fallback to full re-render
  const uri = currentChatUri
  try {
    const doc = $rdf.sym(uri).doc()
    store.removeMatches(null, null, null, doc)

    const subject = $rdf.sym(uri)
    const context = createContext(uri)

    chatContainer.innerHTML = ''
    currentPane = longChatPane.render(subject, context)
    chatContainer.appendChild(currentPane)

  } catch (err) {
    console.error('Error refreshing chat:', err)
  }
}

// Debounced version - prevents rapid re-renders
const refreshChat = debounce(doRefreshChat, 300)

// Load chat function
async function loadChat(uri) {
  if (!uri) {
    alert('Please enter a chat URI')
    return
  }

  // Convert relative URIs to absolute
  if (uri.startsWith('./') || uri.startsWith('../') || !uri.includes('://')) {
    uri = new URL(uri, window.location.href).href
  }

  // Close mobile sidebar if open
  sidebar.classList.remove('open')
  sidebarOverlay.classList.remove('open')

  chatContainer.innerHTML = `
    <div class="placeholder">
      <div class="loading-spinner"></div>
      <p>Loading chat...</p>
    </div>
  `

  try {
    const subject = $rdf.sym(uri)
    const context = createContext(uri)

    // Clear container and render pane
    chatContainer.innerHTML = ''
    currentPane = null

    // Check if pane applies
    const label = longChatPane.label(subject, context)
    if (!label) {
      // Force render anyway for demo
      console.log('Pane label returned null, but rendering anyway for demo')
    }

    currentPane = longChatPane.render(subject, context)
    chatContainer.appendChild(currentPane)

    // Add to chat list (will also set as active)
    addChat(uri)
    chatListPane.setActiveChat(uri)

    // Subscribe to real-time updates
    currentChatUri = uri
    subscribeToUpdates(uri)

  } catch (err) {
    console.error('Error loading chat:', err)
    chatContainer.innerHTML = `
      <div class="placeholder">
        <div class="placeholder-icon">‚ùå</div>
        <h2>Error Loading Chat</h2>
        <p>${err.message}</p>
      </div>
    `
  }
}

// Default global chat
const DEFAULT_CHAT_URI = 'https://solid-chat.solidweb.org/public/global/chat.ttl'

// Initialize: handle auth redirect first, then render sidebar
async function init() {
  // Set initial sound button state
  updateSoundButton()
  document.getElementById('soundToggle').addEventListener('click', toggleSound)

  // Handle auth redirect callback (if returning from IdP)
  await handleAuthRedirect()

  // Create context for sidebar
  const sidebarContext = {
    dom: document,
    session: {
      store: store,
      webId: currentWebId
    }
  }

  // Render chat list sidebar
  const sidebarElement = chatListPane.render(sidebarContext, {
    onSelectChat: loadChat,
    webId: currentWebId
  })
  sidebar.appendChild(sidebarElement)

  // Check for URI in query string, or load default global chat
  const params = new URLSearchParams(window.location.search)
  const initialUri = params.get('uri') || DEFAULT_CHAT_URI
  loadChat(initialUri)
}

init()
</script>

</body>
</html>
